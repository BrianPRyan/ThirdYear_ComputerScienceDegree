/*Brian Ryan K00202212 Computer Graphics Assignment..25/11/2016*/

//points for flagPole nearside
float[] g1 = {100.0,-30.0,-70.0,1.0};  
float[] g2 = {115.0,-30.0,-70.0,1.0};
float[] g3 = {115.0,-150.0,-70.0,1.0};
float[] g4 = {100.0,-150.0,-70.0,1.0};

//points for flagPole far side
float[] g5 = {100.0,-30.0,-80.0,1.0};  
float[] g6 = {115.0,-30.0,-80.0,1.0};
float[] g7 = {115.0,-150.0,-80.0,1.0};
float[] g8 = {100.0,-150.0,-80.0,1.0};

//points for green section of flag nearside
float [] g9 = {225.0,-150.0,-70.0,1.0};
float [] g10 = {225.0,-225.0,-70.0,1.0};
float [] g11 = {115.0,-225.0,-70.0,1.0};

//points for farside flag
float [] g13 = {225.0,-150.0,-80.0,1.0};
float [] g14 = {225.0,-225.0,-80.0,1.0};
float [] g15 = {115.0,-225.0,-80.0,1.0};

//points for nearside of Car
float[] p1 = {20.0,-20.0,55.0,1.0};  
float[] p2 = {80.0,-20.0,55.0,1.0};
float[] p3 = {110.0,-60.0,55.0,1.0};
float[] p4 = {150.0,-60.0,55.0,1.0};
float[] p5 = {180.0,-20.0,55.0,1.0}; 
float[] p6 = {240.0,-20.0,55.0,1.0};
float[] p7 = {240.00,20.0,55.0,1.0};
float[] p8 = {210.0,20.0,55.0,1.0};
float[] p9 = {210.0,10.0,55.0,1.0};
float[] p10 = {200.0,0.0,55.0,1.0};
float[] p11 = {190.00,0.0,55.0,1.0};
float[] p12 = {175.0,10.0,55.0,1.0};
float[] p13 = {175.0,20.0,55.0,1.0};
float[] p14 = {85.0,20.0,55.0,1.0};
float[] p15 = {85.0,10.0,55.0,1.0};
float[] p16 = {70.0,0.0,55.0,1.0};
float[] p17 = {60.0,0.0,55.0,1.0};
float[] p18 = {50.0,10.0,55.0,1.0};
float[] p19 = {50.0,20.0,55.0,1.0};
float[] p20 = {20.0,20.0,55.0,1.0};

//Points for farside of car
float[] b1 = {20.0,-20.0,-20.0,1.0};  
float[] b2 = {80.0,-20.0,-20.0,1.0};
float[] b3 = {110.0,-60.0,-20.0,1.0};
float[] b4 = {150.0,-60.0,-20.0,1.0};
float[] b5 = {180.0,-20.0,-20.0,1.0}; 
float[] b6 = {240.0,-20.0,-20.0,1.0};
float[] b7 = {240.00,20.0,-20.0,1.0};
float[] b8 = {210.0,20.0,-20.0,1.0};
float[] b9 = {210.0,10.0,-20.0,1.0};
float[] b10 = {200.0,0.0,-20.0,1.0};
float[] b11 = {190.00,0.0,-20.0,1.0};
float[] b12 = {175.0,10.0,-20.0,1.0};
float[] b13 = {175.0,20.0,-20.0,1.0};
float[] b14 = {85.0,20.0,-20.0,1.0};
float[] b15 = {85.0,10.0,-20.0,1.0};
float[] b16 = {70.0,0.0,-20.0,1.0};
float[] b17 = {60.0,0.0,-20.0,1.0};
float[] b18 = {50.0,10.0,-20.0,1.0};
float[] b19 = {50.0,20.0,-20.0,1.0};
float[] b20 = {20.0,20.0,-20.0,1.0};

// wheel
float[] w1 = {0.0, 0.0, 0.0, 1.0};   
float[] w2 = {0.0, -10.0, -2.5, 1.0};

//points for nearside Stop Sign
float[] s1 = {100.0,00.0,-60.0,1.0};
float[] s2 = {120.0,00.0,-60.0,1.0};
float[] s3 = {120.0,-80.0,-60.0,1.0};
float[] s4 = {100.0,-80.0,-60.0,1.0};

//points for farside Stop Sign
float[] s5 = {100.0,00.0,-75.0,1.0};
float[] s6 = {120.0,00.0,-75.0,1.0};
float[] s7 = {120.0,-80.0,-75.0,1.0};
float[] s8 = {100.0,-80.0,-75.0,1.0};

//points for nearside top of stop sign
float[] st1 = {140.0,-100.0,-60.0,1.0};
float[] st2 = {140.0,-120.0,-60.0,1.0};
float[] st3 = {120.0,-140.0,-60.0,1.0};
float[] st4 = {100.0,-140.0,-60.0,1.0};
float[] st5 = {80.0,-120.0,-60.0,1.0};
float[] st6 = {80.0,-100.0,-60.0,1.0};

//points for farside top of stop sign
float[] st7 = {140.0,-100.0,-75.0,1.0};
float[] st8 = {140.0,-120.0,-75.0,1.0};
float[] st9 = {120.0,-140.0,-75.0,1.0};
float[] st10 = {100.0,-140.0,-75.0,1.0};
float[] st11 = {80.0,-120.0,-75.0,1.0};
float[] st12 = {80.0,-100.0,-75.0,1.0};

//points for rotating sun - near side
float[] sn1 = {-300.0, -300.0, 0.0, 1.0};
float[] sn2 = {-310.0, -300.0, 0.0, 1.0};
float[] sn3 = {-320.0, -310.0, 0.0, 1.0};
float[] sn4 = {-320.0, -320.0, 0.0, 1.0};
float[] sn5 = {-310.0, -330.0, 0.0, 1.0};
float[] sn6 = {-300.0, -330.0, 0.0, 1.0};
float[] sn7 = {-290.0, -320.0, 0.0, 1.0};
float[] sn8 = {-290.0, -310.0, 0.0, 1.0};

float[] sn9 = {-305.0, -290.0, 0.0, 1.0};
float[] sn10 = {-330.0, -315.0, 0.0, 1.0};
float[] sn11 = {-305.0, -340.0, 0.0, 1.0};
float[] sn12 = {-280.0, -315.0, 0.0, 1.0};

//points for rotating sun - far side
float[] sn13 = {-300.0, -300.0, -10.0, 1.0};
float[] sn14 = {-310.0, -300.0, -10.0, 1.0};
float[] sn15 = {-320.0, -310.0, -10.0, 1.0};
float[] sn16 = {-320.0, -320.0, -10.0, 1.0};
float[] sn17 = {-310.0, -330.0, -10.0, 1.0};
float[] sn18 = {-300.0, -330.0, -10.0, 1.0};
float[] sn19 = {-290.0, -320.0, -10.0, 1.0};
float[] sn20 = {-290.0, -310.0, -10.0, 1.0};

float[] sn21 = {-305.0, -290.0, -10.0, 1.0};
float[] sn22 = {-330.0, -315.0, -10.0, 1.0};
float[] sn23 = {-305.0, -340.0, -10.0, 1.0};
float[] sn24 = {-280.0, -315.0, -10.0, 1.0};

//2D matrices defined by columns, 1st col 2nd col 3rd col 4th col
float[][] scaleMatrix = 
{
{0.9,0.0,0.0,0.0},
{0.0,0.9,0.0,0.0},
{0.0,0.0,0.9,0.0},
{0.0,0.0,0.0,1.0}
};//scaling out at 0.9:1

float[][] translateMatrixIn = {{1.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0},{0.0,0.0,1.0,0.0},{300,300,300,1.0}}; // translate by distance of 310
float[][] translateMatrixOut = {{1.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0},{0.0,0.0,1.0,0.0},{-300,-300,-300,1.0}}; // translate by distance of -310

float theta = radians(10); // convert degrees to radians
 
float[][] rotXMatrix = {{1.0,0.0,0.0,0.0},{0.0,cos(theta),sin(theta),0.0},{0.0,-sin(theta),cos(theta),0.0},{0.0,0.0,0.0,1.0}}; // roatate around x axis
float[][] rotYMatrix = {{cos(theta),0.0,-sin(theta),0.0,0.0},{0.0,1.0,0.0,0.0},{sin(theta),0.0,cos(theta),0.0},{0.0,0.0,0.0,1.0}}; // roatate around y axis
float[][] rotZMatrix= {{cos(theta),sin(theta),0.0,0.0},{-sin(theta),cos(theta),0.0,0.0},{0.0,0.0,1.0,0.0},{0.0,0.0,0.0,1.0}}; // roatate around z axis

float[][] translateMatrixSign = {{1.0,0.0,0.0,0.0},{0.0,1.0,0.0,0.0},{0.0,0.0,1.0,0.0},{-15.0,0.0,0.0,1}};
/*   1  0  0  0   ----> translate along the x axis
     0  1  0  0   ----> translate along the y axis 
     0  0  1  6   ----> translate along the z axis
     0  0  0  1
*/

float[][] m; 

//transform points
float[] transform_point(float[][] m, float[] p)
{

   float[] p_new = {0.0,0.0,0.0,0.0}; // handle 4 elements as its 3D calc
   
   p_new[0] = m[0][0] * p[0] + m[1][0] * p[1] + m[2][0] * p[2] + m[3][0]*p[3];
   p_new[1] = m[0][1] * p[0] + m[1][1] * p[1] + m[2][1] * p[2]+ m[3][1]*p[3];
   p_new[2] = m[0][2] * p[0] + m[1][2] * p[1] + m[2][2] * p[2] +m[3][2]*p[3]; 
   p_new[3] = m[0][3] * p[0] + m[1][3] * p[1] + m[2][3] * p[2] +m[3][3]*p[3]; 
  
   return p_new;
}

//transform points for scaling
void scaleMatrix()
{
  g1 = transform_point(scaleMatrix, g1);
  g2 = transform_point(scaleMatrix, g2);
  g3 = transform_point(scaleMatrix, g3);
  g4 = transform_point(scaleMatrix, g4);
  g5 = transform_point(scaleMatrix, g5);
  g6 = transform_point(scaleMatrix, g6);
  g7 = transform_point(scaleMatrix, g7);
  g8 = transform_point(scaleMatrix, g8);
  g9 = transform_point(scaleMatrix, g9);
  g10 = transform_point(scaleMatrix, g10);
  g11 = transform_point(scaleMatrix, g11);
  g13 = transform_point(scaleMatrix, g13);
  g14 = transform_point(scaleMatrix, g14);
  g15 = transform_point(scaleMatrix, g15);
}

//transform points for translation
void translateMatrixSign()
{
  s1 = transform_point(translateMatrixSign, s1);
  s2 = transform_point(translateMatrixSign, s2);
  s3 = transform_point(translateMatrixSign, s3);
  s4 = transform_point(translateMatrixSign, s4);
  s5 = transform_point(translateMatrixSign, s5);
  s6 = transform_point(translateMatrixSign, s6);
  s7 = transform_point(translateMatrixSign, s7);
  s8 = transform_point(translateMatrixSign, s8);
  st1 = transform_point(translateMatrixSign, st1);
  st2 = transform_point(translateMatrixSign, st2); 
  st3 = transform_point(translateMatrixSign, st3);
  st4 = transform_point(translateMatrixSign, st4);
  st5 = transform_point(translateMatrixSign, st5);
  st6 = transform_point(translateMatrixSign, st6);
  st7 = transform_point(translateMatrixSign, st7);
  st8 = transform_point(translateMatrixSign, st8);
  st9 = transform_point(translateMatrixSign, st9);
  st10 = transform_point(translateMatrixSign, st10);
  st11 = transform_point(translateMatrixSign, st11);
  st12 = transform_point(translateMatrixSign, st12);
}

//transform points for rotation of sun
void applyTransform()
{
  // Apply the transform assigned to matrix m to the points
  sn1 = transform_point(m, sn1);
  sn2 = transform_point(m, sn2);
  sn3 = transform_point(m, sn3);
  sn4 = transform_point(m, sn4);
  sn5 = transform_point(m, sn5);
  sn6 = transform_point(m, sn6);
  sn7 = transform_point(m, sn7);
  sn8 = transform_point(m, sn8);
  sn9 = transform_point(m, sn9);
  sn10 = transform_point(m, sn10);
  sn11 = transform_point(m, sn11);
  sn12 = transform_point(m, sn12);
  sn13 = transform_point(m, sn13);
  sn14 = transform_point(m, sn14);
  sn15 = transform_point(m, sn15);
  sn16 = transform_point(m, sn16);
  sn17 = transform_point(m, sn17);
  sn18 = transform_point(m, sn18);
  sn19 = transform_point(m, sn19);
  sn20 = transform_point(m, sn20);
  sn21 = transform_point(m, sn21);
  sn22 = transform_point(m, sn22);
  sn23 = transform_point(m, sn23);
  sn24 = transform_point(m, sn24);
}

//setup of the scene
void setup() 
{
  //size(1100,1100, P3D);
  size(1500,900,P3D);
  
  //camera(50.0, -80.0, 600.0, 50.0, -70.0, 0.0, 0.0, 1.0, 0.0);//front left angle
  //camera(50.0, -80.0, -500.0, 50.0, -50.0, 0.0, 0.0, 1.0, 0.0);//from behind
  //camera(mouseX, 200.0, 500.0, mouseX, 100, 0, 0, 1, 0);
  
  smooth();
  loop();
  frameRate(10);  
}

//draw function, draws elements in the scene
void draw() 
{   
  
  /*camera(mouseX, height/2, (height/2) / tan(PI/6), width/2, height/2, 0, 0, 1, 0);
  translate(width/1.5, height/1.5, 300);*/
  
  float cameraY = height/2.0;
  float fov = mouseX/float(width) * PI/2;
  float cameraZ = cameraY / tan(fov / 2.0);
  float aspect = float(width)/float(height);
  if (mousePressed) 
  {
    aspect = aspect / 2.0;
  }
  perspective(fov, aspect, cameraZ/10.0, cameraZ*10.0);
  
  translate(width/2+30, height/2, 0);
  rotateX(-PI/6);
  rotateY(PI/3 + mouseY/float(height) * PI);
  translate(0, 0, -50);
  
  background(0);//Sets background colour
  
  scaleMatrix();
  drawFlag();
  
  drawRacingCar();
 
  //draw wheels and translate to correct psoition
  translate(193,20,50);
  drawWheel(20,10,10);
  
  //draw wheels and translate to correct psoition
  translate(0,0,-65);
  drawWheel(20,10,10);
  
  //draw wheels and translate to correct psoition
  translate(-125,0,0);
  drawWheel(20,10,10);
  
  //draw wheels and translate to correct psoition
  translate(0,0,65);
  drawWheel(20,10,10);
  
  //draw axels and translate to correct psoition
  translate(0,0,-30);
  drawWheel(20, 2, 70);   
  
  //draw axels and translate to correct psoition
  translate(125,0,0);
  drawWheel(20, 2, 70);
  
  translateMatrixSign();
  drawStopSign();
  
  //rotating sun around its own Z axes
  //Translate in to the origin
  m = translateMatrixIn;
  applyTransform();                         // Function applies the transform assigned to the matrix m
  //Rotate around Z
  m=rotZMatrix;
  applyTransform();
  //Translate back to original position
  m = translateMatrixOut;
  applyTransform();
  
  drawSun();
  
}

//join points and draw lines of flag
void drawFlag()
{
  strokeWeight(3);
  stroke(0, 0, 255);
  
  line(g1[0],g1[1],g1[2], g2[0],g2[1],g2[2]); // g1 to g2 
  line(g2[0],g2[1],g2[2], g3[0],g3[1],g3[2]); // g2 to g3 
  line(g3[0],g3[1],g3[2], g4[0],g4[1],g4[2]); // g3 to g4 
  line(g4[0],g4[1],g4[2], g1[0],g1[1],g1[2]); // g4 to g1 
  
  line(g5[0],g5[1],g5[2], g6[0],g6[1],g6[2]); // g5 to g6
  line(g6[0],g6[1],g6[2], g7[0],g7[1],g7[2]); // g6 to g7
  line(g7[0],g7[1],g7[2], g8[0],g8[1],g8[2]); // g7 to g8
  line(g8[0],g8[1],g8[2], g5[0],g5[1],g5[2]); // g8 to g5
  
  line(g1[0],g1[1],g1[2], g5[0],g5[1],g5[2]); // g1 to g5
  line(g2[0],g2[1],g2[2], g6[0],g6[1],g6[2]); // g2 to g6
  line(g3[0],g3[1],g3[2], g7[0],g7[1],g7[2]); // g3 to g7
  line(g4[0],g4[1],g4[2], g8[0],g8[1],g8[2]); // g5 to g8
  
  stroke(0, 255,0 );
  line(g3[0],g3[1],g3[2], g9[0],g9[1],g9[2]); // g5 to g8
  line(g9[0],g9[1],g9[2], g10[0],g10[1],g10[2]); // g5 to g8
  line(g10[0],g10[1],g10[2], g11[0],g11[1],g11[2]); // g5 to g8
  line(g3[0],g3[1],g3[2], g11[0],g11[1],g11[2]); // g5 to g8
  
  line(g7[0],g7[1],g7[2], g13[0],g13[1],g13[2]); // g5 to g8
  line(g13[0],g13[1],g13[2], g14[0],g14[1],g14[2]); // g5 to g8
  line(g14[0],g14[1],g14[2], g15[0],g15[1],g15[2]); // g5 to g8
  line(g7[0],g7[1],g7[2], g15[0],g15[1],g15[2]); // g5 to g8}
  
  line(g9[0],g9[1],g9[2], g13[0],g13[1],g13[2]); // g5 to g8
  line(g10[0],g10[1],g10[2], g14[0],g14[1],g14[2]); // g5 to g8
  line(g11[0],g11[1],g11[2], g15[0],g15[1],g15[2]); // g5 to g8

 }

//join points and draw lines of sun
void drawSun()
{
  strokeWeight(3);
  
  stroke(245,184,0);
  
  //connectin lines for nearside of sun
  //line(sn1[0],sn1[1],sn1[2], sn2[0],sn2[1],sn2[2]);   // sn1 to sn2
  line(sn2[0],sn2[1],sn2[2], sn3[0],sn3[1],sn3[2]);     // sn2 to sn3
  //line(sn3[0],sn3[1],sn3[2], sn4[0],sn4[1],sn4[2]);   // sn3 to sn4
  line(sn4[0],sn4[1],sn4[2], sn5[0],sn5[1],sn5[2]); 
  //line(sn5[0],sn5[1],sn5[2], sn6[0],sn6[1],sn6[2]); 
  line(sn6[0],sn6[1],sn6[2], sn7[0],sn7[1],sn7[2]); 
  //line(sn7[0],sn7[1],sn7[2], sn8[0],sn8[1],sn4[2]); 
  line(sn8[0],sn8[1],sn8[2], sn1[0],sn1[1],sn1[2]);
  
  line(sn1[0],sn1[1],sn1[2], sn9[0],sn9[1],sn9[2]);
  line(sn9[0],sn9[1],sn9[2], sn2[0],sn2[1],sn2[2]);
  line(sn3[0],sn3[1],sn3[2], sn10[0],sn10[1],sn10[2]);
  line(sn10[0],sn10[1],sn10[2], sn4[0],sn4[1],sn4[2]); 
  line(sn5[0],sn5[1],sn5[2], sn11[0],sn11[1],sn11[2]); 
  line(sn11[0],sn11[1],sn11[2], sn6[0],sn6[1],sn6[2]); 
  line(sn7[0],sn7[1],sn7[2], sn12[0],sn12[1],sn12[2]); 
  line(sn12[0],sn12[1],sn12[2], sn8[0],sn8[1],sn8[2]); 
 
  //Connecting lines for far side of sun
  //line(sn13[0],sn13[1],sn13[2], sn14[0],sn14[1],sn14[2]); 
  line(sn14[0],sn14[1],sn14[2], sn15[0],sn15[1],sn15[2]); 
  //line(sn15[0],sn15[1],sn15[2], sn16[0],sn16[1],sn16[2]); 
  line(sn16[0],sn16[1],sn16[2], sn17[0],sn17[1],sn17[2]); 
  //line(sn17[0],sn17[1],sn17[2], sn18[0],sn18[1],sn18[2]);
  line(sn18[0],sn18[1],sn18[2], sn19[0],sn19[1],sn19[2]); 
  //line(sn19[0],sn19[1],sn19[2], sn20[0],sn20[1],sn20[2]); 
  line(sn20[0],sn20[1],sn20[2], sn13[0],sn13[1],sn13[2]); 
  
  line(sn13[0],sn13[1],sn13[2], sn21[0],sn21[1],sn21[2]);
  line(sn21[0],sn21[1],sn21[2], sn14[0],sn14[1],sn14[2]);
  line(sn15[0],sn15[1],sn15[2], sn22[0],sn22[1],sn22[2]);
  line(sn22[0],sn22[1],sn22[2], sn16[0],sn16[1],sn16[2]);
  line(sn17[0],sn17[1],sn17[2], sn23[0],sn23[1],sn23[2]);
  line(sn23[0],sn23[1],sn23[2], sn18[0],sn18[1],sn18[2]); 
  line(sn19[0],sn19[1],sn19[2], sn24[0],sn24[1],sn24[2]); 
  line(sn24[0],sn24[1],sn24[2], sn20[0],sn20[1],sn20[2]); 
  
  //connecting points of sun - near to far side
  line(sn9[0],sn9[1],sn9[2], sn21[0],sn21[1],sn21[2]); 
  line(sn10[0],sn10[1],sn10[2], sn22[0],sn22[1],sn22[2]); 
  line(sn11[0],sn11[1],sn11[2], sn23[0],sn23[1],sn23[2]); 
  line(sn12[0],sn12[1],sn12[2], sn24[0],sn24[1],sn24[2]); 
 
}

//join points and draw lines of the racing car
void drawRacingCar()
{
  strokeWeight(3);
  
  //Lines for nearside of car
  stroke(255, 0, 0);//red
  line(p1[0],p1[1],p1[2], p2[0],p2[1],p2[2]); // p1 to p2
  line(p2[0],p2[1],p2[2], p3[0],p3[1],p3[2]); // p2 to p3
  line(p3[0],p3[1],p3[2], p4[0],p4[1],p4[2]); // p3 to p4
  line(p4[0],p4[1],p4[2], p5[0],p5[1],p5[2]); // p4 to p5
  line(p5[0],p5[1],p5[2], p6[0],p6[1],p6[2]); // p5 to p6
  line(p6[0],p6[1],p6[2], p7[0],p7[1],p7[2]); // p6 to p7
  line(p7[0],p7[1],p7[2], p8[0],p8[1],p8[2]); // p7 to p8
  line(p8[0],p8[1],p8[2], p9[0],p9[1],p9[2]); // p8 to p9
  line(p9[0],p9[1],p9[2], p10[0],p10[1],p10[2]); // p9 to p10
  line(p10[0],p10[1],p10[2], p11[0],p11[1],p11[2]); // p10 to p11
  line(p11[0],p11[1],p11[2], p12[0],p12[1],p12[2]); // p11 to p12
  line(p12[0],p12[1],p12[2], p13[0],p13[1],p13[2]); // p12 to p13
  line(p13[0],p13[1],p13[2], p14[0],p14[1],p14[2]); // p13 to p14
  line(p14[0],p14[1],p14[2], p15[0],p15[1],p15[2]); // p14 to p15
  line(p15[0],p15[1],p15[2], p16[0],p16[1],p16[2]); // p15 to p16
  line(p16[0],p16[1],p16[2], p17[0],p17[1],p17[2]); // p16 to p17
  line(p17[0],p17[1],p17[2], p18[0],p18[1],p18[2]); // p17 to p18
  line(p18[0],p18[1],p18[2], p19[0],p19[1],p19[2]); // p18 to p19
  line(p19[0],p19[1],p19[2], p20[0],p20[1],p20[2]); // p19 to p20
  line(p20[0],p20[1],p20[2], p1[0],p1[1],p1[2]); // p20 to p1
  
  //Lines for farside of car
  line(b1[0],b1[1],b1[2], b2[0],b2[1],b2[2]); // b1 to b2
  line(b2[0],b2[1],b2[2], b3[0],b3[1],b3[2]); // b2 to b3
  line(b3[0],b3[1],b3[2], b4[0],b4[1],b4[2]); // b3 to b4
  line(b4[0],b4[1],b4[2], b5[0],b5[1],b5[2]); // b4 to b5
  line(b5[0],b5[1],b5[2], b6[0],b6[1],b6[2]); // b5 to b6
  line(b6[0],b6[1],b6[2], b7[0],b7[1],b7[2]); // b6 to b7
  line(b7[0],b7[1],b7[2], b8[0],b8[1],b8[2]); // b7 to b8
  line(b8[0],b8[1],b8[2], b9[0],b9[1],b9[2]); // b8 to b9
  line(b9[0],b9[1],b9[2], b10[0],b10[1],b10[2]); // b9 to b10
  line(b10[0],b10[1],b10[2], b11[0],b11[1],b11[2]); // b10 to b11
  line(b11[0],b11[1],b11[2], b12[0],b12[1],b12[2]); // b11 to b12
  line(b12[0],b12[1],b12[2], b13[0],b13[1],b13[2]); // b12 to b13
  line(b13[0],b13[1],b13[2], b14[0],b14[1],b14[2]); // b13 to b14
  line(b14[0],b14[1],b14[2], b15[0],b15[1],b15[2]); // b14 to b15
  line(b15[0],b15[1],b15[2], b16[0],b16[1],b16[2]); // b15 to b16
  line(b16[0],b16[1],b16[2], b17[0],b17[1],b17[2]); // b16 to b17
  line(b17[0],b17[1],b17[2], b18[0],b18[1],b18[2]); // b17 to b18
  line(b18[0],b18[1],b18[2], b19[0],b19[1],b19[2]); // b18 to b19
  line(b19[0],b19[1],b19[2], b20[0],b20[1],b20[2]); // b19 to b20
  line(b20[0],b20[1],b20[2], b1[0],b1[1],b1[2]); // b20 to b1
  
  //Lines for joining far and nearside
  line(p1[0],p1[1],p1[2], b1[0],b1[1],b1[2]); // p1 to b1
  line(p2[0],p2[1],p2[2], b2[0],b2[1],b2[2]); // p2 to b2
  line(p3[0],p3[1],p3[2], b3[0],b3[1],b3[2]); // p3 to b3
  line(p4[0],p4[1],p4[2], b4[0],b4[1],b4[2]); // p4 to b4
  line(p5[0],p5[1],p5[2], b5[0],b5[1],b5[2]); // p5 to b5
  line(p6[0],p6[1],p6[2], b6[0],b6[1],b6[2]); // p6 to b6
  line(p7[0],p7[1],p7[2], b7[0],b7[1],b7[2]); // p7 to b7
  line(p8[0],p8[1],p8[2], b8[0],b8[1],b8[2]); // p8 to b8
  line(p9[0],p9[1],p9[2], b9[0],b9[1],b9[2]); // p9 to b9
  line(p10[0],p10[1],p10[2], b10[0],b10[1],b10[2]); // p10 to b10
  line(p11[0],p11[1],p11[2], b11[0],b11[1],b11[2]); // p11 to b11
  line(p12[0],p12[1],p12[2], b12[0],b12[1],b12[2]); // p12 to b12
  line(p13[0],p13[1],p13[2], b13[0],b13[1],b13[2]); // p13 to b13
  line(p14[0],p14[1],p14[2], b14[0],b14[1],b14[2]); // p14 to b14
  line(p15[0],p15[1],p15[2], b15[0],b15[1],b15[2]); // p15 to b15
  line(p16[0],p16[1],p16[2], b16[0],b16[1],b16[2]); // p16 to b16
  line(p17[0],p17[1],p17[2], b17[0],b17[1],b17[2]); // p17 to b17
  line(p18[0],p18[1],p18[2], b18[0],b18[1],b18[2]); // p18 to b18
  line(p19[0],p19[1],p19[2], b19[0],b19[1],b19[2]); // p19 to b19
  line(p20[0],p20[1],p20[2], b20[0],b20[1],b20[2]); // p20 to b20

}

//join points and draw lines of stop sign
void drawStopSign()
{
  strokeWeight(3);
  
  stroke(0, 0, 255);
  
  //Lines for nearside of stop sign
  line(s1[0],s1[1],s1[2], s2[0],s2[1],s2[2]); // s1 to s2
  line(s2[0],s2[1],s2[2], s3[0],s3[1],s3[2]); // s2 to s3
  line(s3[0],s3[1],s3[2], s4[0],s4[1],s4[2]); // s3 to s4
  line(s4[0],s4[1],s4[2], s1[0],s1[1],s1[2]); // s4 to s1
  
  //Lines for far side of stop sign
  line(s5[0],s5[1],s5[2], s6[0],s6[1],s6[2]); // s5 to s6
  line(s6[0],s6[1],s6[2], s7[0],s7[1],s7[2]); // s6 to s7
  line(s7[0],s7[1],s7[2], s8[0],s8[1],s8[2]); // s7 to s8
  line(s8[0],s8[1],s8[2], s5[0],s5[1],s5[2]); // s8 to s5
  
  //Lines to join far and near side of stop sign
  line(s1[0],s1[1],s1[2], s5[0],s5[1],s5[2]); // s1 to s5
  line(s2[0],s2[1],s2[2], s6[0],s6[1],s6[2]); // s2 to s6
  stroke(255,0,0);//red to indicate stop sign
  line(s3[0],s3[1],s3[2], s7[0],s7[1],s7[2]); // s3 to s7
  stroke(0, 0, 255);//blue
  line(s4[0],s4[1],s4[2], s8[0],s8[1],s8[2]); // s4 to s8
  
  //Lines for near side top section of stop sign
  line(s3[0],s3[1],s3[2], st1[0],st1[1],st1[2]);    // s3 to st1
  line(st1[0],st1[1],st1[2], st2[0],st2[1],st2[2]); // st1 to st2
  line(st2[0],st2[1],st2[2], st3[0],st3[1],st3[2]); // st2 to st3
  line(st3[0],st3[1],st3[2], st4[0],st4[1],st4[2]); // st3 to st4
  line(st4[0],st4[1],st4[2], st5[0],st5[1],st5[2]); // st4 to st5
  line(st5[0],st5[1],st5[2], st6[0],st6[1],st6[2]); // st5 to st6
  line(st6[0],st6[1],st6[2], s4[0],s4[1],s4[2]);    // st6 to s4
  
  //Lines for far side top section of stop sign
  line(s7[0],s7[1],s7[2], st7[0],st7[1],st7[2]);          // s7 to st7
  line(st7[0],st7[1],st7[2], st8[0],st8[1],st8[2]);       // st7 to st8
  line(st8[0],st8[1],st8[2], st9[0],st9[1],st9[2]);       // st8 to st9
  line(st9[0],st9[1],st9[2], st10[0],st10[1],st10[2]);    // st9 to st10
  line(st10[0],st10[1],st10[2], st11[0],st11[1],st11[2]); // st10 to st11
  line(st11[0],st11[1],st11[2], st12[0],st12[1],st12[2]); // st11 to st12
  line(st12[0],st12[1],st12[2], s8[0],s8[1],s8[2]);       // st12 to s8
  
  //Lines to join far and near side of top section to indicate stop sign
  stroke(255,0,0);//red
  line(st1[0],st1[1],st1[2], st7[0],st7[1],st7[2]);     // st1 to st7
  line(st4[0],st4[1],st4[2], st10[0],st10[1],st10[2]);  // st4 to st10
  line(st5[0],st5[1],st5[2], st11[0],st11[1],st11[2]);  // st5 to st11
   
  stroke(0, 0, 255);//blue
  line(st2[0],st2[1],st2[2], st8[0],st8[1],st8[2]);     // st2 to st8
  line(st3[0],st3[1],st3[2], st9[0],st9[1],st9[2]);     // st3 to st9
  line(st6[0],st6[1],st6[2], st12[0],st12[1],st12[2]);  // st6 to st12
  
  //Lines for bar to indicate stop sign - near side
  stroke(255,0,0);//red
  line(st5[0],st5[1],st5[2], s3[0],s3[1],s3[2]);    // st5 to s3
  line(st4[0],st4[1],st4[2], st1[0],st1[1],st1[2]); // st4 to st1 
  //Lines for bar to indicate stop sign - far side  
  line(st11[0],st11[1],st11[2], s7[0],s7[1],s7[2]);    // st11 to st7
  line(st10[0],st10[1],st10[2], st7[0],st7[1],st7[2]); // st10 to st7

}

// Draw The Wheels
void drawWheel(int sides, float r, float h)
{
  stroke(255, 255, 255);
  strokeWeight(1);
  fill(0);
  
  float angle = 360 / sides;
  float halfHeight = h / 2;
  
  // draw top shape
  beginShape();
  for (int i = 0; i < sides+1; i++) 
  {
      float x = cos( radians( i * angle ) ) * r;
      float y = sin( radians( i * angle ) ) * r;
      vertex( x + w1[0], y + w1[1], w1[2] - halfHeight ); 
      line(w1[0],w1[1],w1[2] - halfHeight, x + w1[0],y + w1[1],w1[2] - halfHeight);  //centre to point on curve, add half the height to z
      stroke(0, 255, 0); //blue tyres
  }
  endShape(CLOSE);
  
  // draw bottom shape
  beginShape();
  for (int i = 0; i <= sides; i++) 
  {
      float x  = cos( radians( i * angle ) ) * r;
      float y = sin( radians( i * angle ) ) * r;
      vertex( x + w1[0], y + w1[1], w1[2] + halfHeight ); 
      line(w1[0],w1[1],w1[2] - halfHeight, x + w1[0],y + w1[1],w1[2] - halfHeight);  //centre to point on curve, add half the height to z
      line(w1[0],w1[1],w1[2] + halfHeight, x + w1[0],y + w1[1],w1[2] + halfHeight);
      stroke(0, 255, 0); //blue tyres
  }
  endShape(CLOSE);
  
  // draw body
  beginShape(TRIANGLE_STRIP);
  for (int i = 0; i <= sides + 1; i++) 
  {
      float x = cos( radians( i * angle ) ) * r;
      float y = sin( radians( i * angle ) ) * r;   
      vertex(x + w1[0],y + w1[1], w1[2] + halfHeight);  //OK
      vertex(x + w1[0],y + w1[1], w1[2] - halfHeight);  //OK
      stroke(0, 0, 255); // blue tyres
  }
  endShape(CLOSE);
}

//Turn on and off the loop when mouse button pressed
void mousePressed() 
{ 
  loop(); 
} 
 
void mouseReleased() 
{ 
  noLoop(); 
} 
